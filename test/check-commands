#!/bin/bash

# check-commands - Check if commands are available in a Docker image
# Usage: check-commands <docker-image> <command1> [command2] [command3] ...
#        check-commands <docker-image> -f <file-with-commands>
#        check-commands <docker-image> -s <shell> <command1> [command2] ...

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

usage() {
  echo "Usage: $0 <docker-image> <command1> [command2] [command3] ..."
  echo "       $0 <docker-image> -f <file-with-commands>"
  echo "       $0 <docker-image> -s <shell> <command1> [command2] ..."
  echo ""
  echo "Check if commands are available in a Docker image"
  echo ""
  echo "Options:"
  echo "  -f FILE    Read commands from file (one per line)"
  echo "  -s SHELL   Use specified shell (default: sh)"
  echo "  -h         Show this help message"
  echo ""
  echo "Examples:"
  echo "  $0 ubuntu:latest git curl wget"
  echo "  $0 node:18 -f commands.txt"
  echo "  $0 devimage -s zsh git nvim tmux"
  exit 1
}

check_commands_in_container() {
  local image="$1"
  local shell="$2"
  shift 2
  local commands=("$@")

  # Build the command checking script
  local check_script=""
  for cmd in "${commands[@]}"; do
    check_script+="if command -v $cmd >/dev/null 2>&1; then echo \"✓ $cmd\"; else echo \"✗ $cmd\"; fi; "
  done

  # For zsh, force loading of .zshrc by making it interactive
  if [[ "$shell" == "zsh" ]]; then
    docker run --rm --entrypoint="" "$image" "$shell" -i -c "$check_script"
  else
    docker run --rm --entrypoint="" "$image" "$shell" -c "$check_script"
  fi
}

main() {
  if [[ $# -lt 2 ]]; then
    usage
  fi

  local image="$1"
  shift

  # Check if Docker is available
  if ! command -v docker >/dev/null 2>&1; then
    echo -e "${RED}Error: Docker is not installed or not in PATH${NC}" >&2
    exit 1
  fi

  # Check if image exists locally or try to pull it
  echo -e "${YELLOW}Checking Docker image: $image${NC}"
  if ! docker image inspect "$image" >/dev/null 2>&1; then
    echo -e "${YELLOW}Image not found locally, attempting to pull...${NC}"
    if ! docker pull "$image" >/dev/null 2>&1; then
      echo -e "${RED}Error: Could not pull image $image${NC}" >&2
      exit 1
    fi
  fi

  local commands=()
  local use_file=false
  local file_path=""
  local shell="sh"

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
    -f)
      use_file=true
      file_path="$2"
      shift 2
      ;;
    -s)
      shell="$2"
      shift 2
      ;;
    -h)
      usage
      ;;
    *)
      commands+=("$1")
      shift
      ;;
    esac
  done

  # Read commands from file if specified
  if [[ "$use_file" == true ]]; then
    if [[ ! -f "$file_path" ]]; then
      echo -e "${RED}Error: File $file_path not found${NC}" >&2
      exit 1
    fi

    while IFS= read -r line; do
      # Skip empty lines and comments
      [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
      commands+=("$line")
    done <"$file_path"
  fi

  if [[ ${#commands[@]} -eq 0 ]]; then
    echo -e "${RED}Error: No commands specified${NC}" >&2
    usage
  fi

  echo -e "${YELLOW}Checking ${#commands[@]} command(s) in $image:${NC}"
  echo ""

  # Run all commands in a single container session
  local results
  results=$(check_commands_in_container "$image" "$shell" "${commands[@]}")

  # Process results and count available commands
  local available=0
  local total=${#commands[@]}

  while IFS= read -r line; do
    if [[ "$line" =~ ^✓ ]]; then
      echo -e "${GREEN}$line${NC}"
      ((available++))
    elif [[ "$line" =~ ^✗ ]]; then
      echo -e "${RED}$line${NC}"
    else
      # Handle any other output (like .zshrc warnings)
      echo "$line" >&2
    fi
  done <<<"$results"

  echo ""
  echo -e "${YELLOW}Summary: $available/$total commands available${NC}"

  if [[ $available -eq $total ]]; then
    echo -e "${GREEN}All commands are available!${NC}"
    exit 0
  else
    echo -e "${RED}$((total - available)) command(s) missing${NC}"
    exit 1
  fi
}

main "$@"
